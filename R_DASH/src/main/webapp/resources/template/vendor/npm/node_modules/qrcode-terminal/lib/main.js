var QRCode = require('./../vendor/QRCode');
var QRErrorCorrectLevel = require('./../vendor/QRCode/QRErrorCorrectLevel');

var blackAnsi = "\u001b[40m  \u001b[0m";
var whiteAnsi = "\u001b[47m  \u001b[0m";

function toCell(isBlack, useAnsi) {
  if (!useAnsi) return isBlack ? '  ' : '  '; // ANSI 미사용 시 배경 대신 공백(아래 small 모드 유니코드 사용)
  return isBlack ? blackAnsi : whiteAnsi;
}

function repeat(color) {
  return {
    times: function (count) {
      return new Array(count + 1).join(color); // off-by-one fix
    }
  };
}

function fill(length, value) {
  var arr = new Array(length);
  for (var i = 0; i < length; i++) arr[i] = value;
  return arr;
}

function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

module.exports = {
  error: QRErrorCorrectLevel.L,

  setErrorLevel: function (error) {
    this.error = QRErrorCorrectLevel[error] || this.error;
  },

  /**
   * generate(input, opts?, cb?)
   * opts = {
   *   small: boolean       // 유니코드 하프블록으로 2행 -> 1행 압축
   *   margin: number       // quiet zone (기본 2)
   *   ansi: boolean        // ANSI 배경 사용 (기본 true). Windows 호환 위해 false 가능
   *   error: 'L'|'M'|'Q'|'H'
   * }
   */
  generate: function (input, opts, cb) {
    if (typeof opts === 'function') { cb = opts; opts = {}; }
    opts = opts || {};
    var ec = QRErrorCorrectLevel[opts.error] || this.error;
    var margin = (typeof opts.margin === 'number') ? clamp(opts.margin, 0, 10) : 2;
    var useAnsi = opts.ansi !== false; // default true

    var qrcode = new QRCode(-1, ec);
    qrcode.addData(input);
    qrcode.make();

    var output = '';

    if (opts.small) {
      var BLACK = true, WHITE = false;
      var moduleCount = qrcode.getModuleCount();
      var moduleData = qrcode.modules.slice();

      var oddRow = moduleCount % 2 === 1;
      if (oddRow) moduleData.push(fill(moduleCount, WHITE));

      // 유니코드 하프/풀블록 팔레트
      var palette = {
        WHITE_ALL: '\u2588', // █
        WHITE_BLACK: '\u2580', // ▀ (위=흰, 아래=검)
        BLACK_WHITE: '\u2584', // ▄ (위=검, 아래=흰)
        BLACK_ALL: ' '        // 공백(둘 다 검정으로 표현)
      };

      // 상/하 테두리(quiet zone)
      var borderTop = repeat(palette.BLACK_WHITE).times(moduleCount + (margin * 2));
      var borderBottom = repeat(palette.WHITE_BLACK).times(moduleCount + (margin * 2));

      // 위쪽 마진
      for (var mTop = 0; mTop < margin - 1; mTop++) {
        output += borderTop + '\n';
      }
      output += borderTop + '\n';

      for (var row = 0; row < moduleCount; row += 2) {
        // 왼쪽 마진
        output += repeat(palette.WHITE_ALL).times(margin - 1) + palette.WHITE_ALL;

        for (var col = 0; col < moduleCount; col++) {
          var up = moduleData[row][col] === BLACK;
          var down = moduleData[row + 1][col] === BLACK;

          if (!up && !down) output += palette.WHITE_ALL;
          else if (!up && down) output += palette.WHITE_BLACK;
          else if (up && !down) output += palette.BLACK_WHITE;
          else output += palette.BLACK_ALL;
        }

        // 오른쪽 마진
        output += repeat(palette.WHITE_ALL).times(margin) + '\n';
      }

      // 아래쪽 마진
      output += borderBottom;
      for (var mBot = 1; mBot < margin; mBot++) {
        output += '\n' + borderBottom;
      }

    } else {
      // 큰 모드(ANSI 배경)
      var moduleCount2 = qrcode.getModuleCount();
      var border = repeat(useAnsi ? whiteAnsi : '  ').times(moduleCount2 + (margin * 2));
      // 위쪽 마진
      for (var i = 0; i < margin; i++) output += border + '\n';

      qrcode.modules.forEach(function (row) {
        // 왼쪽 마진
        output += repeat(useAnsi ? whiteAnsi : '  ').times(margin);
        // 내용
        output += row.map(function(cell){ return toCell(cell, useAnsi); }).join('');
        // 오른쪽 마진
        output += repeat(useAnsi ? whiteAnsi : '  ').times(margin) + '\n';
      });

      // 아래쪽 마진
      for (var j = 0; j < margin; j++) output += border + (j === margin-1 ? '' : '\n');
    }

    if (cb) cb(output); else return output; // 반환도 지원
  }
};