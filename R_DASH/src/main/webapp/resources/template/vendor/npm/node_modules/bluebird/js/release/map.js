function waitLayerThenBoot(name, cb) {
    const deadline = Date.now() + 3000;
    (function tick() {
        if (window.AppMap && AppMap.layers && AppMap.layers[name]) {
            cb();
            return;
        }
        if (Date.now() > deadline) {
            console.warn('[map.jsp] timed out waiting layer:', name);
            cb();
            return;
        }
        setTimeout(tick, 50);
    })();
}

function boot() {
    const q = new URLSearchParams(location.search);
    const layer = (q.get('layer') || '').toLowerCase();

    if (layer === 'dust') {
        AppMap.activate('dust', {
            airType: q.get('airType') || 'ALL'
        });

    } else if (layer === 'shelter') {
        AppMap.activate('shelter');

    } else if ([ 'fire', 'firestation', 'firestations' ].includes(layer)) {
        AppMap.activate('firestation');

    } else if (layer === 'nowcast') {
        AppMap.activate('nowcast', {
            category: (q.get('category') || 'T1H').toUpperCase(),
            view: (q.get('view') || 'nation').toLowerCase(),
            sidoNm: q.get('sidoNm') || null,
            signguNm: q.get('signguNm') || null
        });

    } else if (layer === 'landslide') {
        // nowcast 잔상 제거
        if (window.AppMap && AppMap.layers && AppMap.layers.nowcast
            && AppMap.layers.nowcast.deactivate) {
            AppMap.layers.nowcast.deactivate();
        }
        const hud = document.getElementById('nowcastHud');
        if (hud) hud.remove();

        AppMap.activate('landslide', {
            sido: q.get('sido') || null,
            sgg: q.get('sgg') || null,
            stts: q.get('stts') || null,
            apntNm: q.get('apntNm') || null,
            cluster: (q.get('cluster') || 'on').toLowerCase() !== 'off'
        });

    } else if (layer === 'sinkhole') {
        AppMap.activate('sinkhole', {
            year: q.get('year') || null,
            sido: q.get('sido') || null,
            stateNm: q.get('stateNm') || null,
            round: Number(q.get('round') || 4) || 4
        });
    }
}

window.addEventListener('appmap:ready', function() {
    const q = new URLSearchParams(location.search);
    const layer = (q.get('layer') || '').toLowerCase();

    if (layer === 'nowcast') {
        document.body.setAttribute('data-nowcast', 'true');
    }
    if (layer)
        waitLayerThenBoot(layer, boot);
    else
        boot();
}, { once : true });

// 로딩 fade-out
document.addEventListener('DOMContentLoaded', function() {
    requestAnimationFrame(function() {
        $('.loading, .overlay').css('opacity', 0);
        setTimeout(function() {
            $('.loading, .overlay').hide();
        }, 400);
    });
});



// ----- 헤더 차지 영역을 자동 계산해서 --header-height에 반영 -----
(function syncHeaderHeightRobust(){
  // 후보 셀렉터(프로젝트에 맞게 추가 가능)
  var CANDIDATES = [
    '#siteHeader','.site-header','#header','.header','.navbar',
    '.tiles-header','.gnb','.topbar','header'
  ];

  function getCandidateElements(){
    var els = [];
    CANDIDATES.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(el){
        if (els.indexOf(el) === -1) els.push(el);
      });
    });
    // 추가로 상단에 붙은 fixed/sticky 요소도 자동 탐색
    document.querySelectorAll('body *').forEach(function(el){
      var cs = getComputedStyle(el);
      if ((cs.position === 'fixed' || cs.position === 'sticky')) {
        var rect = el.getBoundingClientRect();
        // 화면 꼭대기 근처에 붙어 있고 가로로 꽤 넓은 것만
        if (rect.top <= 2 && rect.width >= window.innerWidth * 0.5) {
          if (els.indexOf(el) === -1) els.push(el);
        }
      }
    });
    return els;
  }

  function measureHeaderHeight(){
    var els = getCandidateElements();
    var bottomMax = 0;
    els.forEach(function(el){
      var r = el.getBoundingClientRect();
      // 화면 위쪽(0~150px)에 닿아 있는 요소의 하단값만 고려
      if (r.top <= 150 && r.bottom > 0) {
        bottomMax = Math.max(bottomMax, Math.ceil(r.bottom));
      }
    });
    // fallback
    if (!bottomMax) bottomMax = 90;
    document.documentElement.style.setProperty('--header-height', bottomMax + 'px');
    // 디버깅 확인용
    // console.log('[header-height]', bottomMax, els);
  }

  var raf, queued = false;
  function queueMeasure(){
    if (queued) return;
    queued = true;
    raf = requestAnimationFrame(function(){
      queued = false;
      measureHeaderHeight();
    });
  }

  // 최초/로드/리사이즈/폰트/레이아웃 변화에 반응
  window.addEventListener('load', queueMeasure);
  window.addEventListener('resize', queueMeasure);
  if (document.fonts && document.fonts.addEventListener) {
    document.fonts.addEventListener('loadingdone', queueMeasure);
  }
  if (window.ResizeObserver) {
    var ro = new ResizeObserver(queueMeasure);
    ro.observe(document.body);
  }
  if (window.MutationObserver) {
    var mo = new MutationObserver(queueMeasure);
    mo.observe(document.body, {childList:true, subtree:true, attributes:true});
  }
  // 초기에 한 번
  queueMeasure();
})();
